<!DOCTYPE html>
<html lang="ru">
<head>
  <title>Функциональное программирование на JavaScript</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="node_modules/@shower/material/styles/styles.css">
  <style>
    .shower {
      --slide-ratio: calc(16 / 9);
      --color-key: #ffeb3b;
    }

    .slide a {
      color: #c17900;
    }

    .slide .shout,
    .caption p,
    .caption h1 {
      color: #000;
    }

    .slide > .list-style-disc {
      list-style-type: disc !important;
    }

    .slide > .list-style-disc li:before {
      display: none;
    }


  </style>
</head>
<body class="shower list">

<header class="caption ">
  <h1>Функциональное программирование</h1>
  <p>на JavaScript</p>

</header>


<section class="slide">
  <h2 class="shout">
    Введение</h2>
</section>

<section class="slide">
  <h2>Парадигма программирования это:</h2>
  <ul class="list-style-disc">
    <li class="next">
      «стиль программирования как описания намерений программиста»
    </li>
    <li class="next">
      «модель или подход к решению проблемы»
    </li>
    <li class="next">
      «подход к решению проблем программирования»
    </li>
    <li class="next">
      «способа размышления о компьютерных системах»
    </li>
    <li class="next">
      стиль написания исходного кода компьютерной программы
    </li>
  </ul>
</section>

<section class="slide">
  <h2>Основные модели(парадигмы) программирования</h2>
  <ol>
    <li class="next">Императивное программирование</li>
    <li class="next">Декларативное программирование</li>
    <li class="next">Структурное программирование</li>
    <li class="next">Функциональное программирование</li>
    <li class="next">Логическое программирование</li>
    <li class="next">Объектно-ориентированное программирование</li>
  </ol>
</section>

<section class="slide">
  <figure>
    <img class="cover" src="pictures/paradigms_paradigms.png" alt="Основные модели(парадигмы) программирования">
  </figure>
</section>

<section class="slide">
  <h2>Императивная парадигма включает:</h2>
  <ul lang="ru">
    <li class="next">
      Процедурное программирование
    </li>
    <li class="next">
      Структурное программирование
    </li>
    <li class="next">
      Аспектно-ориентированное программирование
    </li>
    <li class="next">
      Объектно-ориентированное программирование
    </li>
    <li class="next">Обобщённое программирование</li>
  </ul>
</section>

<section class="slide">
  <h2>Императивное программирование</h2>
  <p>
    Императивная программа похожа на приказы
    (англ. imperative — приказ),
    выражаемые повелительным наклонением в естественных языках,
    то есть представляют собой последовательность команд,
    которые должен выполнить компьютер.
  </p>
</section>

<section class="slide">
  <h2>Основные черты императивных языков:</h2>
  <ol class="list-style-disc">
    <li class="next">использование именованных переменных;</li>
    <li class="next">использование оператора присваивания;</li>
    <li class="next">использование составных выражений;</li>
    <li class="next">использование подпрограмм;</li>
    <li class="next">и др.</li>
  </ol>
</section>

<section class="slide">
  <p>При таком способе программирования вы описываете
    <mark><b>как</b></mark>
     получить желаемый результат
  </p>
  <p>На примере заварки Доширака</p>
  <ul>
    <li class="next">Вскипятить воду</li>
    <li class="next">Открыт бп</li>
    <li class="next">Засыпать специи</li>
    <li class="next">Залить кипятком</li>
    <li class="next">Подождать 10 минут</li>

  </ul>
</section>

<section class="slide">
  <figure>
    <img class="cover" src="pictures/navalniy_05.jpg" alt="Эволюция подходов к программированию">
  </figure>
</section>

<section class="slide">
  <h2>Минусы императивного подхода</h2>
  <p class="next">
    Наличие операторов присваивания увеличивает
    сложность модели вычислений и делает императивные
    программы подверженными специфическим ошибкам,
    не встречающимся при функциональном подходе.
  </p>
</section>

<section class="slide">
  <h2>Декларативная парадигма</h2>
  <p class="next">
    Это парадигма программирования, в которой задаётся
    спецификация решения задачи, то есть описывается,
    <mark><b>что</b></mark>
    представляет собой проблема
    и ожидаемый результат.
  </p>

</section>

<section class="slide">
  <h2>Основные черты декларативных языков:</h2>
  <ol class="list-style-disc">
    <li class="next">декларативные программы не используют понятия состояния, то есть не содержат переменных и
                     операторов присваивания;
    </li>
    <li class="next">«Чисто декларативные» компьютерные языки зачастую не полны по Тьюрингу;</li>
  </ol>
</section>

<section class="slide">
  <p>
    Т.е. нам совершенно не интересно, каким именно образом
    машина сделает работу, какие инструкции в каком порядке
    выполнятся и так далее, мы просто объясняем ей, <b>что</b> хотим
    увидеть в результате. Примеры декларативных
    языков - html, css, sql.
  </p>
  <p >Аналогия на примере заварки Доширака</p>
  <ul>
    <li>Хочу заваренный Доширак</li>
  </ul>
  <p></p>
</section>


<section class="slide">
  <figure>
    <img class="cover" src="pictures/navalniy_06.jpg" alt="Эволюция подходов к программированию">
  </figure>
</section>

<section class="slide">
  <h2>Декларативная парадигма включает:</h2>
  <ul lang="ru">
    <li class="next">
      Функциона́льное программи́рование
    </li>
    <li class="next">
      Логи́ческое программи́рование

      <ul lang="ru">
        <li class="next">Аппликативное программирование</li>
        <li class="next">Комбинато́рное программи́рование</li>
        <li class="next">Бесточечное программирование</li>

      </ul>
    </li>
  </ul>
</section>

<section class="slide">
  <h2>Еще раз про декларативное программирование</h2>
  <p class="next">
    <b>Декларативное программирование</b> - это когда в коде описано
    <mark>что</mark>
    должно получиться.
  </p>
  <p class="next">
    Нам совершенно не интересно,
    каким именно компьютер сделает свою работу,
    какие инструкции и в каком порядке выполнятся.
    Мы просто объясняем ей, что хотим увидеть в результате.
  </p>
</section>

<section class="slide">
  <h2>Еще раз про императивное программирование</h2>
  <p class="next">
  <b>Императивное программирование</b> - когда написано
  <mark>как</mark>
                                       это сделать.
  </p>
  <p class="next">
    Программируя императивно, мы описываем конкретные шаги,
    действия и точный порядок, в котором их нужно исполнять.
    Напрямую руководим процессом, непосредственно отдаём приказания.
    Большинство популярных языков императивны, в том числе и javascript.
  </p>

</section>

<section class="slide">
  <h2 class="shout">
    Функциона́льное программи́рование</h2>
</section>

<section class="slide">
  <figure>
    <img class="cover" src="pictures/evolution_paradigms.png" alt="Эволюция подходов к программированию">
  </figure>
</section>

<section class="slide">
  <h2>Функциона́льное программи́рование</h2>
  <p class="next">Раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление
     значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном
     программировании).</p>
</section>

<section class="slide">
    <h2>Другими словами</h2>
    <p class="next">
        Функциональное программирование -
        это стиль разработки ПО, где основной акцент делается на функции
    </p>

    <p class="next">
        Цель ФП состоит в том, чтобы абстрагировать потоки управления и
        операции над данными с помощью функций и тем самым исключить
        побочные эффекты и сократить изменение состояния в приложении.
    </p>
</section>

<section class="slide">
    <figure>
    <img class="cover" src="pictures/understend.jpg" alt="Вырви глаз">
    </figure>
</section>

<section class="slide">
    <h2>Pассмотрим простой пример отображения текста на странице:</h2>
<pre class="next">
<code>&lt;script&gt;
document.querySelector('#msg').innerHTML='&lt;h1&gt;Hello World'&lt;/h1&gt;'
</code>
</pre>

<p class="next">
    Программа проста, но с ее помощью нельзя отображать сообщения в динамическом
    режиме
</p>
</section>

<section class="slide">
    <p>
       Перепишем программу позволяя изменять форматирование, содержимое,
       а возможно и целевой элемент разметки.
    </p>
    <pre class="next">
    <code>&lt;script&gt;
    function printMessage(elementId, format, message) {
        document.querySelector(`#${elementId}`).innerHTML =
        `<${format}>${message}</${format}>`;
        }
    printMessage('msg', 'h1','Hello World');
    </code>
    </pre>
</section>

<section class="slide">
    <h2>Уже лучше =)</h2>
    <p class="next">
        Но.
    </p>
    <p class="next">
        Что если требуется вывести сообщение в файл, а не на HTML страницу.
    </p>
    <p class="next">
        С этой целью придется перенести простой мыслительный процесс создания параметрезованных
        функций на совсем другой уровень, где параметры могут быть не только скалярными
        величинами, но и функциями, предоставляющими дополнительные функциональные возможности.
    </p>

</section>

<section class="slide">
    <h2>Рассмотрим ту же самую программу с применением функционального подхода</h2>
    <pre class="next">
    <code>&lt;script&gt;
    var printMessage = run(addToDom('msg'), h1, echo);
    printMessage('Hello World');
    </code>
    </pre>
</section>

<section class="slide">
    <figure>
    <img class="cover" src="pictures/travolta.gif" alt="Шта">
    </figure>
</section>

<section class="slide">
    <h2>Что же происходит:</h2>
    <ul lang="ru">
        <li class="next">
            Параметр h1 теперь является не скалярной велечиной,
            а функцией подобно <code>addToDom</code> и <code>Echo</code>
        </li>
        <li class="next">
            Процесс декомпозиции(разложения) программы на более мелкие,
            пригодные для повторнорго использования, надежные  и понятные части.
        </li>
        <li class="next">
            Объединение этих частей для формирования всей программы,
            которую легче осмыслить в целом.
        </li>

    </ul>
</section>

<section class="slide">

    <ul lang="ru">
        <li>
            Последовательный вызов функций <code>addToDom</code>,<code>h1</code> и <code>Echo</code>
            при помощи волшебной функции  <code>run</code>
        </li>
    </ul>

    <p class="next">
        Функция <code>run</code> связывает каждую вызываемую функцию в цепочку,
        где значение вызываемое из предыдыущей функции, передается в качестве параметра
        следующей функции.
    </p>
    <p class="next">
        В данном случае "Hello World", возвращаемая из <code>Echo()</code>,
        передается <code>h1()</code>, а резуальтат разметки передается <code>addToDom()</code>.
    </p>

</section>

<section class="slide">
    <h2>
        Функция run:
    </h2>
    <pre class="next">
    <code>&lt;script&gt;
    run = function(f, g, h) {
        return function(x) {
            return f(g(h(x)))
        }
    }
    </code>
    </pre>

</section>

<section class="slide">
    <h2>
        Функция addToDom:
    </h2>
    <pre class="next">
    <code>function addToDom(elementId) {
    return function(content) {
        document.querySelector(#${elementId})
                .innerHTML = content;
        }
    }
    </code>
    </pre>

</section>

<section class="slide">
    <h2>
        Функция h1:
    </h2>
    <pre class="next">
    <code>&lt;script&gt;
        function h1(message) {
            return '&lt;h1&gt;' + message + '&lt;/h1&gt;'
        }
    </code>
    </pre>

</section>

<section class="slide">
    <h2>
        Функция echo:
    </h2>
    <pre class="next">
    <code>&lt;script&gt;
        function echo(message) {
            return message
        }
    </code>
    </pre>

</section>

<section class="slide">
    <h2>Все вместе:</h2>
    <pre class="next">
    <code>&lt;script&gt;
    var printMessage = run(addToDom('msg'), h1, echo);
    printMessage('Hello World');
    </code>
    </pre>
</section>

<section class="slide">
    <h2>Почему так?</h2>
    <p class="next">
        По существу, данное решение лучше рассматривать как параметризацию
        прикладного кода, которую легко изменить, ничего не нарушая,
        подобно коррекции начальных условий алгоритма.
    </p>


</section>

<section class="slide">
    <p >
        Таким образом можно легко расширить возможности программы <code>printMessage</code>
    </p>
    <p class="next">
       Чтобы повторить сообщение дважды, воспользоваться заголовком h2 и организовать
       вывод в консоль, вместо модел DOM.
    </p>
    <pre class="next">
    <code>&lt;script&gt;
    var printMessage = run(console.log, repeat(3), h2, echo);
    printMessage('Get Functional');
    </code>
    </pre>

</section>


<section class="slide">
    <p >
        Сравнивая функциональное и не функциональное решение, мы видим радикальное отличие и ситль программирования.
    </p>
    <p >
        И это объявсняется декларативным характером разработки, который присущ ФП.
    </p>

</section>

<section class="slide">
  <h2>Понятия и принципы на которых основано функциональное программирование</h2>
  <ul class="list-style-disc">
    <li class="next">
      Декларативное программирование(Declarative programming)
    </li>
    <li class="next">
      Чистые функции (Pure functions)
    </li>
    <li class="next">
      Ссылочная прозрачность (Referential transparency)
    </li>
    <li class="next">
      Неизменяемость (Immutability)
    </li>

  </ul>
</section>

<section class="slide">
  <h2>Декларативный харатктер функционального программирования</h2>
</section>

<section class="slide">
  <p> Рассмотрим решение простой задачи в разных парадигмах</p>
  <pre class="next">
  <code>&lt;script&gt;
  <span class="comment">//Возведем в квадрат все числа массива(императивно)</span>
  const array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
  for(let i = 0; i < array.length; i++) {
    array[i] = Math.pow(array[i], 2);
  }
  array; //-> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

        </code>
      </pre>
</section>

<section class="slide">
  <p>
    При императивном программировании компьютер
    получает подробные инструкции , как выполнить
    определенную задачу.
  </p>
  <p class="next">
    В данном случае применить формулу возведения в
    квадрат к каждому числу на отдельном шаге цикла.
  </p>
</section>

<section class="slide">
  <h2>Решение той же задачи</h2>
  <pre>

  <code>&lt;script&gt;
  <span class="comment">//в декларативном подходе</span>
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(num => Math.pow(num,2));
  //-> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
        </code>
      </pre>
</section>

<section class="slide">
  <p>
    Достаточно позаботиться
    о применении правильного поведения к каждому элементу,
    уступив управление циклом другим частям программы.
  </p>

  <p class="next">
    Данный код освобождает от ответственности за надлежащее
    управление счетчика цикла и доступом к массиву по индексую.
  </p>

  <p class="next">
    Другими словами, чем больше кода, тем больше в нем мест для
    программных ошибок.
  </p>
</section>

<section class="slide">
  <h2>Чистые функции</h2>

  <p class="next">
    Для чистой функуии харатерны следующие свойства:
  </p>

  <ul>
    <li class="next">
      Зависит только от входных данных, а не от любого
      скрытого или веншнего состояния, которое может
      изменится во время ее вычисления или в промежутках между ее вызовами.
    </li>
    <li class="next">
      Не вносит изменеия за пределами своей области видимости, например не
      изменяет глобальный объект или параметр, передаваемый по ссылке.
    </li>
  </ul>
</section>

<section class="slide">
  <h2>Пример</h2>

  <pre>
  <code>&lt;script&gt;
let counter = 0;
function increment() {
  return ++counter;
}
  </code>
      </pre>

</section>

<section class="slide">
  <h2>Является ли функция чистой?</h2>

  <p class="next">
      Эта функция является "нечистой" потому, что она читает или модифицирует
      внешнюю переменную <code>counter</code>, которая не является локальной
      в области видимости данной функции.
  </p>
  <p class="next">
      В общем можно сказать, что у данной функции имеются побочные эффекты,
      если в ней читаются данные из внешних источников или записываются
      данные во внешние источники.
  </p>
</section>

<section class="slide">
    <figure>
        <img class="cover" src="pictures/side-effect.jpg" alt="Побочный эффект функции">
    </figure>
</section>


    <section class="slide">
        <h2>Побочные эффекты могут возникать во многих случаях, например:</h2>
        <ul>
            <li class="next">
                Глобальное изменение переменной, свойства или структуры данных.
            </li>
            <li class="next">
                Обработка вводимых пользователем данных.
            </li>
            <li class="next">
                Генерирование исключения, если только оно не перехватывается в той же самой функции.
            </li>
            <li class="next">
                Вывод сообщений на экран или в журнал регистрации.
            </li>
            <li class="next">
                Запрос HTML-документов, браузерных cookie-файлов или баз данных.
            </li>
        </ul>
    </section>



    <section class="slide">
        <h2>
            Если в программе нильзя создавать и модифицировать объекты или выводить информацию
            на экран, то какая практическая польза от такой программы?
        </h2>
        <p class="next">
            На практике функциональное программирование накладывает
            ограничение не на все изменения состояния.
        </p>
        <p class="next">
            Оно лишь предоставляет каркас, помогающий управлять ими
            и сокращать их, позволяя в тоже время отделить "чистое от нечистого".
        </p>
    </section>

    <section class="slide">
        <p class="next">
            Расмотрим пример императивной программы. В которой выполняется поиск
            учащегося по его номеру социального страхования и отображения его в браузере.
        </p>
    </section>

    <section class="slide">
            <figure>
                <img class="cover" src="pictures/example-search-student.png" alt="Поиск студента">
            </figure>
    </section>

    <section class="slide">
        <figure>
            <img class="cover" src="pictures/example-search-student2.png" alt="Поиск студента">
        </figure>
    </section>

    <section class="slide">
        <figure>
            <img class="cover" src="pictures/example-search-student3.png" alt="Поиск студента">
        </figure>
    </section>


    <section class="slide">
        <figure>
            <img class="cover" src="pictures/example-search-student4.png" alt="Поиск студента">
        </figure>
    </section>

    <section class="slide">
        <h2>Побочные эффекты:</h2>
        <ul>
            <li class="next">
                Ссылка внути функции на внешнюю переменню(db) для доступа к данным, в любой момент
                ссылка может стать пустой(null), или изменится в промежутке межу вывзовами функции.
            </li>
            <li class="next">
                Глобальная переменная elementId, может в любой момент измениться, выйдя из под контроля.
            </li>

        </ul>
    </section>

    <section class="slide">
        <h2>Побочные эффекты:</h2>
        <ul>
            <li class="next">
                Элементы HTML-разметки модифицируются непосредственно. А сам HTML документ является изменяемым,
                общим, глобальным ресурсом.
            </li>
            <li class="next">
                Эта функция может сгенерировать исключения, если учащийся не найден, что может привести к
                сворачиванию  стека вызовов и аварийному завершению программы.
            </li>
        </ul>
    </section>

    <section class="slide">
        <p>
            Изменим функцию использую функциональный подход
        </p>

        <ul>
            <li class="next">
                Разделим длинную функцию на более короткие функции с отдельным назначением.
            </li>
            <li class="next">
               Сократим количество побочных эффектов, явно определив все
               аргументы, которые требуются функциям для выполнения их значений.
            </li>
        </ul>
    </section>

    <section class="slide">
        <figure>
            <img class="cover" src="pictures/example-search-student-update.png" alt="Поиск студента">
        </figure>
    </section>

    <section class="slide">
        <figure>
            <img class="cover" src="pictures/example-search-student-update2.png" alt="Поиск студента">
        </figure>
    </section>

    <section class="slide">
        <figure>
            <img class="cover" src="pictures/example-search-student-update3.png" alt="Поиск студента">
        </figure>
    </section>

    <section class="slide">
        <figure>
            <img class="cover" src="pictures/example-search-student-update3.png" alt="Поиск студента">
        </figure>
    </section>

    <section class="slide">
        <figure>
            <img class="cover" src="pictures/example-search-student-total.png" alt="Поиск студента">
        </figure>
    </section>


    <section class="slide">
        <figure>
            <img class="cover" src="pictures/example-search-student-total2.png" alt="Поиск студента">
        </figure>
    </section>

    <section class="slide">
        <h2>Таким образмо мы получаем следующие преимущества:</h2>
        <ul>
            <li class="next">
               Программа стала более гибкой, т.к. теперь она состоит из 3 повторно используемых компонентов
            </li>
            <li class="next">
               Повторное использование мелкоструктырных ф-ций направленно на повышение производительности,
               поскольку оно позволяет значительно сократить объем кода, требующего активного сопровождения.
            </li>
            <li class="next">
                Удобочитаемость исходного кода.
            </li>
            <li class="next">
                Взаимодействие с объектами HTML-разметки переносится в отдельню ф-цию,
                полностью отделяя "чистое" поведение от "нечистого".
            </li>
        </ul>
    </section>


    <section class="slide">
       <h2>Ссылочная прозрачность</h2>
        <p class="next">
            Ссылочная прозрачность является более формальным способом определения
            "чистой" функции.
        </p>

        <p class="next">
           <i>"Чистота"</i> в этом смысле означает существование "чистого" соответствия
           аргументов функции ее возвращаемому значению.
        </p>

        <p class="next">
            Так, если функция постоянно возвращает один и тот же результат по
            тем же самым входным данным, то она считается <i>ссылочно-прозрачной</i>.
         </p>
    </section>

    <section class="slide">
        <p>
            Например, рассмотренная ранее функция <code>Increment()</code>,
            сохранаяющая состояние, не
            является ссылочно-прозрачной, т.к.
            возвращаемое значение сильно зависит от
            внешней переменной <code>counter</code>
        </p>
<pre class="next">
<code>&lt;script&gt;
    let counter = 0;
    function increment() {
        return ++counter;
    }
</code>
        </pre>
    </section>

    <section class="slide">
        <h2>
          Как сделать функцию ссылочно-прозрачной?
        </h2>

<pre class="next">
<code>&lt;script&gt;
    const increment = counter => counter + 1;
</code>
</pre>
    <p class="next">
        Исключить зависимое состояние(т.е. внешнюю переменную),
        превартив его в формальный параметр, явно определив в
        <i>сигнатуре</i> данной функции.
    </p>
    </section>

    <section class="slide">
        <p class="note">
            <i>
                Сигнатура — часть общего объявления функции, позволяющая средствам
                трансляции идентифицировать функцию среди других. То есть это название функции и ее параметры.
            </i>
        </p>

        <p class="next">
            Теперь данная функция стабильна и всегда
            возвращает один и тот же результат.
        </p>
        <p class="next">
            Иначе на возвращаемое значение, будет оказывать влияне какой-нибудь внешний фактор.
        </p>

    </section>

    <section class="slide">
        <p>
            Данное свойство желательно в функциях
            потому, что оно упрощает не только тестирование,
            но и понимание всей программы в целом.
        </p>
        <p class="next">
            С помощью волшебной функции <code>run()</code>
            сравним применение функциональной и императивной
            версии <code>increment()</code>.
        </p>
    </section>
    <section class="slide">
        <figure>
            <img class="cover" src="pictures/imperative-declarative.png" alt="Сравним императивную и функциональную версию incremen()">
        </figure>
    </section>

    <section class="slide">
        <figure>
            <img class="cover" src="pictures/imperative-declarative2.png" alt="Сравним императивную и функциональную версию incremen()">
        </figure>
    </section>


    <section class="slide">
        <figure>
            <img class="cover" src="pictures/imperative-declarative3.png" alt="Сравним императивную и функциональную версию incremen()">
        </figure>
    </section>


    <section class="slide">
        <p>
           Таким образом используюя функциональный подход можно составить в уме модель состояния
           системы и добиться желаемого результата посредством <i>переписывания</i> или <i>подстановки</i>.
        </p>

        <p class="next">
            Рассмотрим более конкретный пример, допустив, что любую программу можно
            представить в виде ряда функций.
        </p>
        <p class="next">
            Обрабатывающих заданные входные данные и получающих конечный результат.
        </p>
    </section>

    <section class="slide">
        <p>
           Выразим это допущение в псевдофрорме следующим образом
        </p>
<pre class="next">
<code>&lt;script&gt;
    Program = [Input] + [func1, func2, func3, ...] -> Output
</code>
</pre>
    </section>

    <section class="slide">
        <p>
                Если функции <code>func1, func2, func3</code> являются "чистыми",
                то данную программу можно переписать, подставив получаемые
                в них значения:
            </p>
<pre class="next">
<code>&lt;script&gt;
    Program = [Input] + [val1, val2, val3, ...] -> Output
</code>
</pre>
    </section>

    <section class="slide">
        <p>
            Расмотрим пример вычисление средней оценки учащегося:
        </p>
<pre class="next">
<code>&lt;script&gt;
    const input = [80, 90, 100];
    const average = (arr) => divide(sum(arr), size(arr));
    average (input); //-> 90
</code>
</pre>

    </section>

    <section class="slide">
        <p>
            Благодаря ссылочной прозрачности функции <code>some()</code>
            и <code>size()</code> выражение
<pre class="next">
<code>&lt;script&gt;
    const average = (arr) => divide(sum(arr), size(arr));
</code>
</pre>
        </p>
        <p class="next">
            Можно переписать для заданных входных данных:
        </p>
<pre class="next">
<code>&lt;script&gt;
    const average = divide(270, 3); //-> 90
</code>
</pre>
    </section>

    <section class="slide">
        <p>
            Функция <code>divide()</code> всегда "чистая",
            и поэтому ее можно переписать используюя
            ее математическое обозначение.
        </p>
        <p class="next">
            Таким образом, для тех же самых входных данных
            средняя оцентка всегда равна <b>270/3 = 90</b>
        </p>

        <p class="next">
            Ссылочная прозрачность дает возможность анализировать программы подобным
            систематическим и почти математическим образом.
        </p>
    </section>

    <section class="slide">
        <p>
            Полная реализация программы:
        </p>
<pre class="next">
<code>&lt;script&gt;
    const sum = (total, current) => total + current;
    const total = arr => arr.reduce(sum);
    const size = arr => arr.length;
    const divide = (a, b) => a / b;
    const average = arr => divide(total(arr), size(arr));
    average(input); //-> 90
</code>
</pre>

    </section>

    <section class="slide">
        <p>
           Определив заранее все аргументы функции, можно избежать побочных эффектов в
           большинстве случаев, когда задаются скалярные значения.
        </p>

        <p class="next">
            Но если функции передаются объекты по ссылке, следует принять особые
            меры предосторожности, чтобы не изменить эти объекты неумышленно.
        </p>
    </section>

    <section class="slide">
        <h2>Сохранение данных неизменяемыми(immutable data)</h2>
    </section>


    <section class="slide">
        <p>
            Неизменяемыми называются такие данные, которые нельзя изменить после их создания.
        </p>

        <p class="next">
           Пример:
        </p>

<pre class="next">
<code>&lt;script&gt;
const sortDesc = function (arr) {
    return arr.sort(function (a, b) {
        return b - a;
    });
}
</code>
</pre>
    </section>

    <section class="slide">
        <p>
           На первый взгляд, код идеально чист от побочных эффектов.
        </p>
        <p class="next">
            Он делает то, что от него требуется, обрабатывая получаемый массив.
            И возвращая его отстортированным по убывающей.
        </p>

<pre class="next">
<code>&lt;script&gt;
    var arr = [1,2,3,4,5,6,7,8,9];
    sortDesc(arr); //-> [9,8,7,6,5,4,3,2,1]
</code>
</pre>
    </section>

    <section class="slide">
        <p>
            Но функция <code>Array.sort()</code> сохраняет состояние, вызывая
            побочный эффект сортировки массива на месте, в результате чего изменяется
            первоначальная ссылка
        </p>

        <p class="next">
            Но если функции передаются объекты по ссылке, следует принять особые
            меры предосторожности, чтобы не изменить эти объекты неумышленно.
        </p>
    </section>

    <section class="slide">
        <p>
            Итак сущность ФП можно выразить в более краткой форме.
        </p>

        <p class="next">
            <i>Функциональное программирование означает декларативное вычисление "чистых функций"
                для создания неизменяемых программ, исключая внешние наблюдаемеы
                побочные эффекты.
            </i>
        </p>
    </section>


    <section class="slide">
        <p>
            Большинство трудностей с которыми сталкиваются разработчики приложений
            на javascript, обусловленны  интенсивным применением крупных функций.
        </p>

        <p class="next">
            Которые в значительной степени зависят от внешних общих переменных,
            выполняют немало операций ветвления и не обладают ясной структурой.
        </p>

        <p class="next">
            Образую общую сеть изменяемых, глобальных данных, которые с трудом
            поддаются отслеживанию и отладке.
        </p>
    </section>

    <section class="slide">
        <h2>
            Таким образ ФП способно:
        </h2>

            <ul>
                <li class="next">
                    Побуждать к декомпозиции рещаемых задач на простые функции;
                </li>
                <li class="next">
                    Обрабатывать данные, используя текучие цепочки;
                </li>
                <li class="next">
                    Уменьшать сложность управляемого событиями кода, применяя принципы реактивного программирования;
                </li>
            </ul>
    </section>



    <section class="slide">
        <h2>
            Побуждение к декомпозиции:
        </h2>

        <p class="next">
           По существу ФП, означает определенное сочетание декомпозиции(разложения программы на мелкие части) и
           композиции(соединения отдельных частей в единое целое)
        </p>

        <p class="next">
            Как на примере программы showStudent
        </p>
    </section>

    <section class="slide">
        <figure>
            <img class="cover" src="pictures/example-search-student-total2.png" alt="Поиск студента">
        </figure>
    </section>

    <section class="slide">
        <figure>
            <img class="cover" src="pictures/decompostion.png" alt="декомпозиции(разложения программы на мелкие части)">
        </figure>
    </section>

    <section class="slide">
        <h2>
            Побуждение к декомпозиции:
        </h2>

        <p class="next">
            Изначально мы пользовались вошлебной функцие run(), чтобы соеденить вместе функции, образующую целую программы.
        </p>

        <p class="next">
           На самом деле run - это псевдоним композиции - одной из самы важных методик ФП.
        </p>

        <p class="next">
          Композиция 2 функций дает еще одну ф-цию, которая получается в результате подключения
          выхода одной функции на вход другой.
        </p>
    </section>


    <section class="slide">
        <h2>
           Рассмотрим блок схему композици программы showStudent:
        </h2>

    </section>

    <section class="slide">
        <figure>
            <img class="cover" src="pictures/compose.png" alt="декомпозиции(разложения программы на мелкие части)">
        </figure>
    </section>


    <section class="slide">
        <h2>
            Побуждение к декомпозиции:
        </h2>
        <p class="next">
            Поток данных композиции 2 функций. Значение возвращаеме из ф-ции find(),
            должно быть совместиммы по типу и количеству аргуменов(арности)
            с функцие csv(),возавращающей, в свою очередь, информацию, которая
            может быть использована в вункции append()
        </p>

        <p class="next">
            Функции compos() передаются дргуие функции в качестве аргументов и
            поэтому она назватся <i>функцией высшего порядка</i>.
        </p>

    </section>



    <section class="slide">
        <h2>
            Резюме:
        </h2>
        <ul>
            <li class="next">
               Код, в котором применяютия "чистые" функции, неспособен изменить
               или нарушить глобальное состояние, что помогает сделать
               код более удобным для тестирования и сопровождения.
            </li>
            <li class="next">
               ФП осуществляется в декларативном стиле, упрощающем понимание прикладного кода.
            </li>
            <li class="next">
                Обработка данных, хранящихся в элементах коллекции,
                плавно выполняется по цепочки функций, связывающих вмесете такие операции
                как map и reduce.
            </li>
        </ul>

    </section>


    <section class="slide">
        <h2>
            Резюме:
        </h2>
        <ul>
            <li>
                В функциональном программировании функции рассматриваются как стандартные блоки
                с учетом того, что функции первого класса и высшего порядка улучшают модульность
                и повторное использование прикладного кода.
            </li>
            <li class="next">
                Сложность управляемых событиями программ можно уменьшить,
                сочетая функиональное программирование с реактивным.
            </li>
        </li>
        </ul>

    </section>


    <section class="slide">
            <figure>
                <img class="cover" src="pictures/slowpoke_on_crutches.jpg" alt="декомпозиции(разложения программы на мелкие части)">
            </figure>
        </section>





<section class="slide">
  <h2>Источники иформации</h2>
  <ul lang="ru">
    <li>
      <a target="_blank"
         href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">
        wikipedia.org
      </a>
    </li>
    <li>
      <a target="_blank"
         href="https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-1-6ef98e90d58d">
        medium.com
      </a>
    </li>
    <li>
      <a target="_blank" href="https://tproger.ru/translations/imperative-declarative-programming-concepts/">
        tproger.ru
      </a>
    </li>
    <li>
      <a target="_blank" href="https://www.ozon.ru/context/detail/id/142823895/">
        Функциональное программирование на JavaScript.
      </a>
    </li>
    <li>
      <a target="_blank" href="https://habr.com/ru/post/154105/">
        habr.com
      </a>
    </li>

    <li>
      <a target="_blank" href="https://frontender.info/the-two-pillars-of-javascript-pt-2-functional-programming/">
        frontender.info
      </a>
    </li>
  </ul>
</section>

<div class="progress"></div>

<script src="node_modules/shower-core/shower.min.js"></script>
<!-- Copyright © 3000 Yours Truly, Famous Inc. -->

</body>
</html>

